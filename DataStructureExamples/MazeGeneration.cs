using System;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using DataStructures.Basic;
using DataStructures.PrimitiveWrappers;
using DataStructures.Interfaces;
using DataStructures.Algorithms;

namespace DataStructureExamples
{
    public partial class MazeGeneration : Form
    {
        private const int MAZE_OFFSET = 20; //spacing on the outside of the maze
        private const int DOUBLE_OFFSET = 40; //used to find the spacing on both sides of the maze
        private const int CELL_OFFSET = 4; //inner padding in a cell

        private DisjointSets<DSInteger> my_d_sets; //holds cell sets for the algorithm
        private DirectedGraph<DSInteger> my_maze_graph; //holds cells as vertices and removed walls as edges for the solution algorithm
        private List<Wall> my_walls; //walls in the maze
        private List<Wall> my_removed_walls; //walls removed from the maze (edges in the graph)
        private List<DSInteger> my_solution_path; //solution generated by algorithm
        private List<DSInteger> my_user_solution_path; //user attempted solution

        //state variables for the algorithms and user input
        private int my_rows, my_cols;
        private bool my_maze_generated = false;
        private bool my_generating = false;
        private bool my_accepting_user_input = false;

        //drawing variables
        private float my_single_w_cell_spacer;
        private float my_single_h_cell_spacer;
        private float my_double_w_cell_spacer;
        private float my_double_h_cell_spacer;

        private float my_draw_width;
        private float my_draw_height;
        private float my_cell_width;
        private float my_cell_height;
        
        private Bitmap my_buffer;
        private Bitmap my_clip;

        //the various sizes the maze generation allows
        private int[] my_sizes = new int[] { 8, 16, 32, 48, 64, 96, 128, 160, 192, 224, 256 };

        /// <summary>
        /// Initializes the maze generation application and its child controls.
        /// </summary>
        public MazeGeneration()
        {
            InitializeComponent();

            //select the first items from the rows/cols combos
            cmbSize.SelectedIndex = 0;
        }

        /// <summary>
        /// Builds the maze and forces a visual update to see the maze.
        /// </summary>
        private void generateMaze()
        {
            //don't queue up generation of mazes
            if (!my_generating)
            {
                my_generating = true;

                //track time taken during the algorithm
                long start_time = DateTime.Now.Ticks;

                //get dimensions we need
                my_rows = my_sizes[cmbSize.SelectedIndex];
                my_cols = my_rows;

                //helper variables
                int total_cells = my_rows * my_cols;
                int row_walls = my_rows - 1;
                int col_walls = my_cols - 1;
                int total_ver_walls = my_rows * col_walls;
                int total_hor_walls = row_walls * my_cols;

                //initialize (progress maximum = preparings sets, preparing walls (hor/ver) and set unions)
                initializeGeneration(total_cells + total_hor_walls + total_ver_walls + total_cells - 1);

                //add all sets to the disjoint sets class
                for (int i = 0; i < total_cells; i++)
                {
                    my_d_sets.addSet(new DSInteger(i));
                    updateProgress();
                }

                //prepare vertical walls
                for (int i = 0; i < my_rows; i++)
                {
                    for (int j = 0; j < col_walls; j++)
                    {
                        int row_total = i * my_cols;
                        my_walls.add(new Wall(new DSInteger(row_total + j), new DSInteger(row_total + j + 1)));
                        updateProgress();
                    }
                }

                //prepare horizontal walls
                for (int i = 0; i < row_walls; i++)
                {
                    for (int j = 0; j < my_cols; j++)
                    {
                        int row_total = i * my_cols;
                        my_walls.add(new Wall(new DSInteger(row_total + j), new DSInteger(row_total + j + my_cols)));
                        updateProgress();
                    }
                }

                //scramble the ordering in the walls well (three times)
                Wall[] scramble = my_walls.toArray();
                Randomization.shuffleArray<Wall>(ref scramble);
                Randomization.shuffleArray<Wall>(ref scramble);
                Randomization.shuffleArray<Wall>(ref scramble);

                //prepare list of walls
                my_walls.clear();
                //add to linked list for cost-effective removal
                for (int i = 0; i < scramble.Length; i++)
                {
                    my_walls.add(scramble[i]);
                }

                int count = 0;
                //generate the maze
                Iterator<Wall> it = my_walls.iterator();
                while (it.hasNext())
                {
                    Wall w = it.next();

                    //if the cells don't belong to the same set
                    if (my_d_sets.find(w.cell_one) != my_d_sets.find(w.cell_two))
                    {
                        //union the sets and remove the wall
                        my_d_sets.union(w.cell_one, w.cell_two);
                        my_removed_walls.add(it.remove());
                        count++;
                        updateProgress();
                    }

                    //check if all cells belong to the same set
                    if (count == total_cells - 1) //once they are a tree will exist with n-1 edges (total_cells-1 edges)
                    {
                        break;
                    }
                }

                //cleanup
                cleanupGeneration(start_time, total_cells);

                my_generating = false;
            }
        }

        //performs cleanup operations after the main generation algorithm.
        private void cleanupGeneration(long the_start_time, int the_total_cells)
        {
            //flag a bad solution
            my_solution_path = null;

            //mark the generation time
            TimeSpan span = new TimeSpan(DateTime.Now.Ticks - the_start_time);
            lblTimeToGenerateMaze.Text = "Generation: " + (span.TotalSeconds).ToString("F3") + " secs";

            //show wall/cell number
            lblCells.Text = "Cell Count: " + the_total_cells;

            //show wall/cell number
            lblWalls.Text = "Wall Count: " + my_walls.size();

            //update the maze
            pnlDraw.Refresh();

        }

        //performs initialization before the main generation algorithm.
        private void initializeGeneration(int the_progress_max)
        {
            //mark that the panel can be drawn now
            if (!my_maze_generated)
            {
                my_maze_generated = true;

                lblStart.Visible = true;
                lblFinish.Visible = true;
            }

            //clear out old labels
            lblSolutionPathLength.Text = "";
            lblTimeToSolveMaze.Text = "";

            //clear out old structures
            my_maze_graph = null;
            my_user_solution_path = null;
            my_buffer = null;

            //clear out old values
            my_accepting_user_input = false;

            //setup progressbar
            pbrProgress.Value = 0;
            pbrProgress.Maximum = the_progress_max;

            my_walls = new LinkedList<Wall>();
            my_removed_walls = new LinkedList<Wall>();

            //prepare sets
            my_d_sets = new DisjointSets<DSInteger>();
        }

        //updates the progress bar.
        private void updateProgress()
        {
            pbrProgress.Value += 1;
        }

        //generates a graph representing the maze (if not already generated).
        private void generateGraph()
        {
            if (my_maze_graph == null)
            {
                my_maze_graph = new DirectedGraph_AL<DSInteger>();

                //add all cells as vertices
                int total_cells = my_rows * my_cols;
                for (int i = 0; i < total_cells; i++)
                {
                    my_maze_graph.addVertex(new DSInteger(i));
                }

                //add all removed walls as edges
                Iterator<Wall> it = my_removed_walls.iterator();
                while (it.hasNext())
                {
                    Wall w = it.next();
                    my_maze_graph.addEdge(w.cell_one, w.cell_two, 0.0);
                    my_maze_graph.addEdge(w.cell_two, w.cell_one, 0.0);
                }
            }
        }

        //shows the solution of the graph to the user.
        private void showSolution()
        {
            //if not already solved
            if (my_solution_path == null)
            {
                long start_time = DateTime.Now.Ticks;

                //generate graph if necessary
                generateGraph();

                //find all shortest paths and record the one in we need
                my_maze_graph.unweighted(new DSInteger(0));
                my_solution_path = my_maze_graph.getShortestPath(new DSInteger(my_rows * my_cols - 1));

                //mark the solution time
                TimeSpan span = new TimeSpan(DateTime.Now.Ticks - start_time);
                lblTimeToSolveMaze.Text = "Solution: " + (span.TotalSeconds).ToString("F3") + " secs";

                //mark the path length of the solution
                lblSolutionPathLength.Text = "Path to Finish: " + my_solution_path.size() + " cells";

                //update the maze
                drawSolution();
            }
        }

        //updates all visuals and internal values after the size of the window changes.
        private void updateAfterResize()
        {
            //quick out for bad window size
            if (ClientRectangle.Width == 0 || ClientRectangle.Height == 0)
            {
                return; 
            }

            //get base dimensions
            my_draw_width = (pnlDraw.Width - DOUBLE_OFFSET);
            my_draw_height = (pnlDraw.Height - DOUBLE_OFFSET);
            my_cell_width = my_draw_width / my_cols;
            my_cell_height = my_draw_height / my_rows;

            my_single_w_cell_spacer = .1f * my_cell_width;
            my_single_h_cell_spacer = .1f * my_cell_height;
            my_double_w_cell_spacer = my_single_w_cell_spacer * 2;
            my_double_h_cell_spacer = my_single_h_cell_spacer * 2;

            //setup clip for removing highlights
            Bitmap bitmap = new Bitmap(BackgroundImage, ClientRectangle.Width, ClientRectangle.Height);
            my_clip = new Bitmap(pnlDraw.Width, pnlDraw.Height);

            Graphics g = Graphics.FromImage(my_clip);
            g.DrawImage(bitmap, new Rectangle(0, 0, my_clip.Width, my_clip.Height),
                new Rectangle(pnlDraw.Left, pnlDraw.Top, pnlDraw.Width, pnlDraw.Height), GraphicsUnit.Pixel); 
        }

        //draws the trail of user moves in the maze.
        private void drawUserSolution(bool the_full_redraw, DSInteger the_removed)
        {
            //draw solution if there
            if (my_user_solution_path != null)
            {
                if (the_full_redraw)
                {
                    drawList(my_user_solution_path, Color.Green, pnlDraw.CreateGraphics());
                }
                else
                {
                    //only draw the new move
                    if (the_removed == null)
                    {
                        drawHighlight(my_user_solution_path.last(), Color.Green,  pnlDraw.CreateGraphics()); 
                    }
                    else //remove that retraced move
                    {
                        removeCellHighlight(the_removed, pnlDraw.CreateGraphics());
                    }
                }
            }
        }

        //draws the algorithm's solution to the maze.
        private void drawSolution()
        {
            //draw solution if there
            if (my_solution_path != null)
            {
                drawList(my_solution_path, Color.Black, pnlDraw.CreateGraphics());
            }
        }

        //gets an x,y value using clock arithmetic on the maze's cell number.
        private void getXY(int the_cell_num, out float the_x, out float the_y)
        {
            the_x = the_cell_num % my_cols;
            the_y = the_cell_num / my_rows; 
        }

        //removes the highlighting from a single cell (for user back-tracking).
        private void removeCellHighlight(DSInteger the_removal, Graphics the_g)
        {
            float x, y;

            getXY(the_removal.value, out x, out y);

            //draw over the removed highlight
            the_g.DrawImage(my_clip, MAZE_OFFSET + x * my_cell_width + my_single_w_cell_spacer,
                                  MAZE_OFFSET + y * my_cell_height + my_single_h_cell_spacer,
                                  new RectangleF(MAZE_OFFSET + x * my_cell_width + my_single_w_cell_spacer,
                                                 MAZE_OFFSET + y * my_cell_height + my_single_h_cell_spacer,
                                                 my_cell_width - my_double_w_cell_spacer,
                                                 my_cell_height - my_double_h_cell_spacer), GraphicsUnit.Pixel);
        }

        //draws a list of user/algorithm moves through the maze.
        private void drawList(List<DSInteger> the_list, Color the_color, Graphics the_g)
        {
            //loop through the path to the correct solution and draw the path
            Iterator<DSInteger> it = the_list.iterator();
            while (it.hasNext())
            {
                DSInteger next = it.next();
                drawHighlight(next, the_color, the_g);
            }
        }

        //draws a single move in the maze.
        private void drawHighlight(DSInteger the_element, Color the_color, Graphics the_g)
        {
            //get the x, y coordinates
            float x, y;
            getXY(the_element.value, out x, out y);

            //draw the highlight
            the_g.FillRectangle(new SolidBrush(the_color), MAZE_OFFSET + x * my_cell_width + my_single_w_cell_spacer,
                                                           MAZE_OFFSET + y * my_cell_height + my_single_h_cell_spacer,
                                                           my_cell_width - my_double_w_cell_spacer,
                                                           my_cell_height - my_double_h_cell_spacer);
        }

        //moves the user through the maze depending on the input received.
        private void move(MazeMove the_move)
        {
            //if the user pull up the hint, then remove it
            if (my_solution_path != null)
            {
                my_solution_path = null;
                pnlDraw.Refresh();
            }

            //generate graph if necessary
            generateGraph();

            DSInteger current_move = my_user_solution_path.last();
            List<SimpleEdge<DSInteger>> next_moves = my_maze_graph.getEdgesIncidentTo(current_move); //get the next moves in the graph (adjacent vertices)
            DSInteger check;
            bool found = false;

            //which move was chosen
            switch (the_move)
            {
                case MazeMove.Up:
                    check = new DSInteger(current_move.value - my_cols);
                    if (checkContains(next_moves, check))
                    {
                        found = true;
                    }
                    break;
                case MazeMove.Down:
                    check = new DSInteger(current_move.value + my_cols);
                    if (checkContains(next_moves, check))
                    {
                        found = true;
                    }
                    break;
                case MazeMove.Left:
                    check = new DSInteger(current_move.value - 1);
                    if (checkContains(next_moves, check))
                    {
                        found = true;
                    }
                    break;
                default: //right
                    check = new DSInteger(current_move.value + 1);
                    if (checkContains(next_moves, check))
                    {
                        found = true;
                    }
                    break;
            }

            //if the user can move in that direction (no wall - an edge exists in the graph)
            if (found)
            {
                //check for backtracking (the second to last element was the last move
                if (my_user_solution_path.size() > 1 && my_user_solution_path.get(my_user_solution_path.size() - 2).Equals(check))
                {
                    //the last element is my_current_move
                    DSInteger removed = my_user_solution_path.removeAt(my_user_solution_path.size() - 1);

                    //update the maze
                    drawUserSolution(false, removed);
                }
                else
                {
                    my_user_solution_path.add(check);
                    drawUserSolution(false, null);
                }

                //check for reaching the finish node
                userReachsFinish(my_user_solution_path.last());
            }
        }

        //checks whether a list of simple edges contains a second label.
        private bool checkContains(List<SimpleEdge<DSInteger>> the_adjacent, DSInteger the_check)
        {
            Iterator<SimpleEdge<DSInteger>> it = the_adjacent.iterator();
            while (it.hasNext())
            {
                if (it.next().second_label.Equals(the_check))
                {
                    return true;
                }
            }
            return false;
        }

        //inform the user that they reaced the finish of the maze.
        private void userReachsFinish(DSInteger the_check)
        {
            //this checks for the last cell's index in the maze
            if (the_check.value == my_rows * my_cols - 1)
            {
                MessageBox.Show("Congratulations on reaching the finish node. See if you can " + 
                    "reach the finish node faster than the shortest path algorithm used.");
            }
        }

        //---------------------- CONTROL EVENT HANDLERS -----------------------

        //draws the maze on a panel.
        private void pnlDraw_Paint(object sender, PaintEventArgs e)
        {
            //only draw if a maze has been generated.
            if (my_maze_generated)
            {
                Graphics g;
                if (my_buffer == null)
                {
                    //get dimensions/spacing for drawing
                    updateAfterResize();

                    my_buffer = new Bitmap(pnlDraw.Width, pnlDraw.Height);
                    g = Graphics.FromImage(my_buffer);
                    Pen p = new Pen(new SolidBrush(Color.Black), 2.0f);

                    //draw outer edge 
                    float right_x = MAZE_OFFSET + my_draw_width;
                    float bottom_y = MAZE_OFFSET + my_draw_height;
                    g.DrawLine(p, MAZE_OFFSET, MAZE_OFFSET, right_x, MAZE_OFFSET); //top edge
                    g.DrawLine(p, right_x, MAZE_OFFSET, right_x, bottom_y - my_cell_height); //right edge
                    g.DrawLine(p, MAZE_OFFSET, bottom_y, right_x, bottom_y); //bottom edge
                    g.DrawLine(p, MAZE_OFFSET, MAZE_OFFSET + my_cell_height, MAZE_OFFSET, bottom_y); //left edge

                    //make pen small for maze drawing
                    p = new Pen(new SolidBrush(Color.Black), 1.0f);

                    //draw walls
                    int count = 0;
                    Iterator<Wall> it = my_walls.iterator();
                    while (it.hasNext())
                    {
                        //update periodically
                        count++;
                        if (count % 1000 == 0)
                        {
                            Application.DoEvents();
                        }

                        Wall w = it.next();

                        float x1, x2, y1, y2;

                        //vertical wall
                        if (w.cell_one.value == w.cell_two.value - 1)
                        {
                            x1 = w.cell_two.value % my_cols;
                            y1 = w.cell_one.value / my_rows;

                            x2 = x1;
                            y2 = y1 + 1;
                        }
                        else //horizontal wall
                        {
                            x1 = w.cell_one.value % my_cols;
                            y1 = w.cell_two.value / my_rows;

                            x2 = x1 + 1;
                            y2 = y1;
                        }

                        g.DrawLine(p, MAZE_OFFSET + x1 * my_cell_width,
                                      MAZE_OFFSET + y1 * my_cell_height,
                                      MAZE_OFFSET + x2 * my_cell_width,
                                      MAZE_OFFSET + y2 * my_cell_height);
                    }
                }

                g = e.Graphics;
                g.DrawImage(my_buffer, new Rectangle(0, 0, pnlDraw.Width, pnlDraw.Height),
                    new Rectangle(0, 0, my_buffer.Width, my_buffer.Height), GraphicsUnit.Pixel);

                //draw solution if there is one
                drawSolution();
                drawUserSolution(true, null);
            }
        }

        //generates the maze by user request.
        private void btnGenerate_Click(object sender, EventArgs e)
        {
            generateMaze();
        }

        //shows the solution of the maze.
        private void btnShowSolution_Click(object sender, EventArgs e)
        {
            showSolution();
        }

        //checks for user key input for manually traversing the maze.
        private void MazeGeneration_KeyPress(object sender, KeyPressEventArgs e)
        {
            //only accept input on a generated maze and after the button has been pressed
            if (my_accepting_user_input)
            {
                //wasd moves the user through the maze
                if (e.KeyChar == 'w')
                {
                    move(MazeMove.Up);
                }
                else if (e.KeyChar == 'a')
                {
                    move(MazeMove.Left);
                }
                else if (e.KeyChar == 's')
                {
                    move(MazeMove.Down);
                }
                else if (e.KeyChar == 'd')
                {
                    move(MazeMove.Right);
                }
            }
        }

        //lets the user manually traverse the maze.
        private void btnTryIt_Click(object sender, EventArgs e)
        {
            //only accept input when the user has asked to solve the puzzle themselves
            if (my_maze_generated)
            {
                my_accepting_user_input = true;

                //remove hint path
                my_solution_path = null;

                my_user_solution_path = new ArrayList<DSInteger>();
                my_user_solution_path.add(new DSInteger(0));

                //update the maze
                pnlDraw.Refresh();
            }
        }

        //updates the visual after the window's size has changed.
        private void MazeGeneration_SizeChanged(object sender, EventArgs e)
        {
            updateAfterResize();
            my_buffer = null;
        }

        /// <summary>
        /// Helper class for determining what cells are on each side of a wall.
        /// </summary>
        private class Wall
        {
            private DSInteger my_cell_one;
            private DSInteger my_cell_two;

            /// <summary>
            /// Sets up the wall with two cells adjacent to it.
            /// </summary>
            /// <param name="the_cell_one">the first cell.</param>
            /// <param name="the_cell_two">the second cell.</param>
            public Wall(DSInteger the_cell_one, DSInteger the_cell_two)
            {
                my_cell_one = the_cell_one;
                my_cell_two = the_cell_two;
            }

            /// <summary>
            /// Gives a string representation of the wall and its two adjacent cells.
            /// </summary>
            /// <returns>a string representation.</returns>
            public override string ToString()
            {
                StringBuilder builder = new StringBuilder();

                //show both walls
                builder.Append("Wall1: ");
                builder.Append(my_cell_one);
                builder.Append(", ");
                builder.Append("Wall2: ");
                builder.Append(my_cell_two);

                return builder.ToString();
            }

            /// <summary>
            /// Access to cell one.
            /// </summary>
            public DSInteger cell_one
            {
                get { return my_cell_one; }
                set { my_cell_one = value; }
            }

            /// <summary>
            /// Access to cell two.
            /// </summary>
            public DSInteger cell_two
            {
                get { return my_cell_two; }
                set { my_cell_two = value; }
            }
        }

        /// <summary>
        /// Direction enum for user input.
        /// </summary>
        private enum MazeMove
        {
            Up,
            Down,
            Left,
            Right
        }
    }
}
